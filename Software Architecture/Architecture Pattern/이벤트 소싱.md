# 이벤트 소싱
### 이벤트 소싱이란?
* 데이터 저장 방식 중 하나로 **발생한 이벤트를 저장하는 기법**
* 이벤트 위주로 비즈니스 로직을 구현하고, 애그리거트를 DB에 일련의 이벤트로 저장하는 기법
  * 애그리거트: DDD에 기반한 설계에서 **하나의 도메인에서 필요한 객체들을 하나로 모아놓은 것. 하나의 트랜잭션에서는 하나의 애그리거트만 업데이트**
* 각 이벤트는 애그리거트의 상태 변화를 나타냄
* 이벤트 저장소에 해당 이벤트를 순차적으로 저장해서 관리. **이벤트의 최종 결과값이 아닌 전체 순서를 모두 저장하여 관리**

### 이벤트 소싱 실사용 예시
* **버전 관리 시스템**
  * 변경 내역만 저장
  * 지금 상태를 볼 때는 변경 내역을 재생

### 이벤트 소싱을 사용하는 이유
* 전통적인 방식 (기존 영속화 방식: ORM) 과의 비교
  * 애그리거트가 업데이트되면 이전 상태가 없어진다.
  * 따라서 관리 용도로 보존하려면 추가 개발이 필요하다.
  * 비즈니스 로직과 동기화되도록 개발해야 하므로 개발 난이도가 높다.
* MSA에서는 각 서비스마다 각자의 데이터를 가지게 된다.
  * 데이터의 정합성을 보장하는 게 어려워진다.
  * 따라서 데이터를 가진 서비스가 바로 데이터를 조작하게 하면 안 된다.
  * 이를 해결하기 위해 서비스는 이벤트를 발생시키고 **Event store**에 저장, **이벤트 컨슈머**가 해당 이벤트를 **들어온 순서대로 적재**하고 필요 데이터를 변경한다.
* 이벤트 소싱은 **클라우드에서 구동되는 메시지 중심의 분산 시스템**에 적합하다.

### 이벤트 소싱의 특징
* 이벤트를 재생하면 특정 애그리거트 상태를 그대로 **재연**할 수 있다.
* 이벤트 소싱은 쓰기에 적합하지만 읽기에는 매우 비효율적인 구조이다.
  * **CQRS** (Command and Query Responsibility Segregation) 를 적용하면 읽기 성능을 높일 수 있다.
    * **명령** (Command)과 **조회** (Query) 분리
    * 명령으로 이벤트를 적재하고 Read 모델에서 조회
      * Read 모델: 새 이벤트는 이벤트 버스를 통해 전파되는데, Read 모델은 이벤트 리스너로 발행되는 이벤트를 관찰하고 있다가 Read 모델을 갱신해야 하는 이벤트가 발행하는 순간에 이를 갱신
  * **이벤트 소싱 + CQRS**
    1. Command가 발생하면 command API에 요청 전달
    2. Command를 처리하는 서비스는 Event store에 API 처리 결과 저장
    3. 이벤트가 처리된 후 이벤트 브로커로 결과가 전송
    4. 이벤트는 제한적이며, 이벤트 기반의 독립적인 형태로 통합됨
    5. 이 이벤트는 Queries API로 전달되며 View store에 저장됨.
    6. 이후 클라이언트로부터 Query가 요청되면 View store에 동기화된 데이터를 조회하게 됨

### 이벤트 저장소 구현


### 이벤트 소싱의 단점

