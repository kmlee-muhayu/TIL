# Kafka의 Offset 관리
### 개요
* Kafka의 컨슈머가 `poll()`을 호출할 때마다, 컨슈머 그룹은 Kafka에 저장되어 있지만 아직 읽지 않은 메시지들을 가져와 처리한다.
* 이는 Kafka의 메시지를 어디까지 읽었는지 저장하고 있기 때문에 가능한 일인데, 이를 **Offset**이라는 값에 저장하게 된다.
* Kafka에 저장되는 각 레코드들은 파티션 별로 독립적인 Offset 값을 가지게 되고, 컨슈머 그룹이 파티션 별로 마지막으로 읽은 레코드의 Offset을 저장함으로써 읽은 메시지와 읽지 않은 메시지를 구분한다.
### Commit
#### Offset에 문제가 생기는 경우
* 컨슈머는 내부적으로 Offset 정보를 저장하고 이를 사용해 읽지 않은 메시지들만 파티션에서 읽어올 수 있다.
* 하지만 어떤 상황에는 내부적으로 존재하는 정보를 사용할 수 없는 경우가 존재한다.
  1. 컨슈머가 갑자기 다운되는 경우
     * 기존에 파티션을 배정받아 처리하던 컨슈머가 다운되어 해당 파티션을 처리할 컨슈머가 존재하지 않게 되는 경우
  2. 컨슈머 그룹에 새로운 컨슈머가 조인할 경우
     * 새로 조인한 컨슈머가 파티션을 배정받지 않아 노는 경우
* 컨슈머 그룹은 이를 해결하기 위해 그룹 내에서 컨슈머들의 리밸런싱을 수행하게 되는데, 이 때 컨슈머들이 기존에 배정받은 파티션과 **다른 파티션을 할당받게 될 수 있어 내부적으로 저장한 Offset 정보를 사용할 수 없게** 된다.
#### Commit이 탄생한 이유
* 이를 위해 Kafka에서는 **내부 토픽에 Offset 정보를 저장**하고 **Offset 값을 업데이트**하는 것을 **Commit** 이라고 한다.
* 리밸런스를 거치게 되면 컨슈머들이 기존과 다른 파티션을 할당받을 수 있기 때문에 가장 최근의 Offset 값을 가져와 메시지를 다시 읽는 과정을 수행한다.
#### Commit 방법
##### 자동 커밋
* 자동 커밋 방식은 Kafka 애플리케이션에서 사용하는 기본적인 방식으로, 실행한 주기에 따라 `poll()`울 호출할 때 자동으로 마지막 Offset을 Commit 한다.
* 컨슈머 옵션 중 `enable.auto.commit=true`로 설정하면 자동 커밋 방식을 사용해 Offset을 관리할 수 있다.
* 커밋을 하기 위한 주기는 기본적으로 5초마다 커밋을 하게 되고, 이는 `auto.commit.interval.ms` 설정값으로 조정할 수 있다.
* 자동 커밋은 Offset 관리를 자동으로 할 수 있다는 장점이 있는 반면, **리밸런싱으로 인한 문제**가 발생할 수 있다는 점을 염두해야 한다.
* 메시지 중복 수신이 발생할 수 있기 때문에 메시지 처리에 있어 **멱등성**을 생각해야 한다.
  * 중복으로 메시지를 처리하더라도 결과에 변동이 되지 않도록 설계를 잘 해야 한다.
##### 수동 커밋
* 메시지 처리가 **완벽하게 이루어지지 않으면 메시지를 읽지 않은 것**으로 간주해야 할 경우 사용된다.
* 수동 커밋도 자동 커밋과 마찬가지로 메시지의 중복이 발생할 수 있다.
* 즉, 어떤 커밋 방식을 사용하더라도 메시지가 중복되는 것은 피할 수 없는 문제이다.
  * 이는 Kafka에서 기본적으로 `Exactly-Once` 방식이나 `At-Least-On` 방식을 채용하고 있기 때문인데, **중복은 발생할 수 있지만 손실은 발생하지 않는다는** 원칙이다.

