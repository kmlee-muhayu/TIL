# 쿠버네티스 (Kubernetes)
### 전통적인 배포 시대
* 전통적인 배포 때에는 물리 서버에 애플리케이션을 실행했다.
* 한 물리 서버에서 여러 애플리케이션의 한계를 정의할 방법이 없기 때문에, 리소스 할당 문제 발생
	* 물리 서버 하나에서 무거운 인스턴스를 돌릴 경우 다른 인스턴스에 대한 성능이 저하됨
* 당시 서로 다른 **여러 물리 서버**에서 각 애플리케이션을 실행하여 이러한 문제를 해결하려 함
	* 이는 많은 물리 서버를 유지해야 하기 때문에 많은 비용을 요구하였으며 안정적이지만 비효율적인 구조였음
### 가상화된 배포 시대
* 가상화된 배포 시대에는 단일 물리 서버의 CPU에서 여러 가상 시스템 (Virtual Machine) 을 실행할 수 있게 함
* **하나의 Host OS 위에 여러 개의 OS를 실행한다는 점**에서 가상 시스템은 리소스를 많이 잡아먹어 무겁다는 단점이 있음
### 컨테이너 개발 시대
* **컨테이너** : VM과 유사하지만 가상화를 좀 더 경량화된 프로세스의 개념으로 만든 기술을 의미
	* Host OS 위에 컨테이너 엔진을 설치하고, 애플리케이션 작동에 필요한 바이너리, 라이브러리 등을 하나로 모아 각자가 별도의 서버인 것처럼 사용하는 환경
* 컨테이너는 **이전보다 빠르고 가볍게 가상화를 구현할 수 있게** 해주었으며, **유연하고 자유로운 마이크로서비스**를 관리하기 용이하게 해주었음
### 쿠버네티스란?
* **탄력적인 컨테이너 운용**을 위한 솔루션
* 만약 컨테이너가 다운되면 **시스템이 복제해두었던 다른 컨테이너를 다시 실행하는 방식**으로 문제를 해결한다면 어떨까?
	* 위와 같은 생각에서 컨테이너 오케스트레이션 도구가 등장함
      * **컨테이너 오케스트레이션** : 컨테이너화된 애플리케이션에 대한 자동화된 설정, 관리 및 제어 체계
      * 쿠버네티스는 컨테이너 오케스트레이션 도구 중 가장 널리 사용되는 오픈소스 툴
### 관련 용어
|용어|의미|
|---|---|
|컨테이너|애플리케이션이 구동되는 환경까지 감싸서 실행할 수 있도록 하는 격리 기술|
|컨테이너 런타임|컨테이너를 다루는 도구|
|도커|컨테이너를 다루는 도구 중 가장 많이 사용되는 도구|
|쿠버네티스|컨테이너 런타임을 통해 컨테이너를 오케스트레이션하는 도구|
|오케스트레이션|여러 서버에 걸친 컨테이너 및 사용하는 환경 설정을 관리하는 행위|
### 쿠버네티스 특징
1. 모든 리소스는 **오브젝트 형태**로 관리
	* 쿠버네티스에서는 **컨테이너의 집합**(Pods), 컨테이너의 집합을 관리하는 **컨트롤러**(ReplicaSet), 사용자(Service Account), 노드(Node)까지 하나의 오브젝트로 사용할 수 있다.
    * `kubectl api-resource`
      * 쿠버네티스에서 사용할 수 있는 오브젝트 종류 출력 명령어
    * `kubectl explain pod[오브젝트]`
      * 특정 오브젝트의 간략한 설명 출력
2. 명령어를 사용할 수 있지만 기본적으로 **YAML 파일**을 더 많이 사용
	* 쿠버네티스의 대부분의 작업은 `kubectl` 이라는 명령어로 실행할 수 있다.
    * YAML 파일로 컨테이너 뿐 아니라 거의 모든 오브젝트들에 사용될 수 있다.
      * 컨테이너 자체, 컨테이너 설정값(ConfigMap), 비밀값(Secrets) 등도 모두 YAML 파일로 정의해 사용 가능
    * 실제 서비스를 배포시킬 때도 여러 개의 YAML 파일을 정의해 쿠버네티스에 적용시키는 방식으로 동작한다.
3. **여러 개의 컴포넌트**로 구성되어 있음
	* 쿠버네티스 노드의 역할은 크게 **마스터**와 **워커**로 나눈다.
### 쿠버네티스의 기능
* **서비스 디스커버리와 로드밸런싱**
	* 쿠버네티스는 별도의 DNK 구성 없이 DNS 이름을 사용하거나 IP 주소를 사용하여 컨테이너를 노출할 수 있다.
    * 트래픽이 많아지면 쿠버네티스는 자동으로 네트워크 트래픽을 로드밸런싱하여, 배포가 안정적으로 이루어질 수 있도록 한다.
* **스토리지 오케스트레이션**
	* 로컬 저장소, 공용 클라우드 등과 같이 원하는 저장소 시스템을 자동으로 탑재할 수 있다.
* **자동화된 롤아웃과 롤백**
	* 배포된 컨테이너의 원하는 상태를 서술할 수 있으며, 원하는 상태로 설정한 속도에 따라 변경할 수 있다.
    * 장애 시 애플리케이션 롤백 또한 지원
* **자동화된 빈 패킹 (bin packing)**
	* 각 컨테이너에 필요한 CPU 및 메모리의 양을 지정할 수 있다.
      * 컨테이너화된 작업을 실행하는 데 사용할 수 있는 쿠버네티스 클러스터 노드를 제공하여, 쿠버네티스는 컨테이너를 노드에 맞추어 리소스를 가장 잘 사용할 수 있도록 해줌
* **시크릿과 구성 (config) 관리**
	* 암호, OAuth 토큰 및 SSH 키와 같은 중요한 정보를 저장하고 관리할 수 있다.
    * 컨테이너 이미지를 재구성하지 않고 스택 구성에 시크릿을 저장하지 않고도 시크릿 및 애플리케이션 구성을 배포 및 업데이트할 수 있다.
* **자동화된 복구**
	* 쿠버네티스는 패한 컨테이너를 다시 시작하고, 컨테이너를 교체하며, 사용자 정의 상태 검사에 응답하지 않는 컨테이너를 죽이고, 서비스 준비가 끝날 때까지 이러한 과정을 클라이언트에게 보여주지 않는다.
* **배치 실행**
	* 배치 (실시간으로 처리하는 것이 아닌 일괄적으로 모아 한 번에 처리하는 것) 단위 작업을 실행할 수 있도록 하며, 주기적인 배치 작업도 실행할 수 있다.
* **오토 스케일링**
	* 자동으로 애플리케이션의 스케일을 넓히거나 줄일 수 있다. (Horizontal Scaling)
### 쿠버네티스의 핵심 컨셉
* 쿠버네티스는 명령형 인터페이스가 아닌 선언형 인터페이스를 사용
	* 어떤 동작을 지시하는 것이 아닌 **원하는 상태를 선언**하는 것
    * 이러한 방식을 *쿠버네티스 네이티브* 하다고 함
* 쿠버네티스는 **현재 상태**와 **선언된 상태** (desired state) 가 일치하는지 지속적으로 확인함
	* 상태가 서로 다를 경우, 선언된 상태에 맞게 복구될 수 있도록 필요한 조치를 취하게 됨
      * 쿠버네티스의 모든 것은 **Objects** 와 **Controller** 를 중심으로 돌아감
        * Objects : **사용자의 의도를 담은 레코드**
          * Objects를 생성함으로써 클러스터의 워크로드를 어떤 형태로 보이고 싶은지를 효과적으로 쿠버네티스에게 전달할 수 있음
          * 주요 Objects
            * **Pod**
              * 쿠버네티스에서 배포할 수 있는 가장 작은 단위로, 한 개 이상의 컨테이너와 스토리지, 네트워크 속성을 가짐
              * Pod에 속한 컨테이너는 스토리지와 네트워크를 공유하고 서로 localhost로 접근할 수 있음
            * **ReplicaSet** : Pod를 한 개 이상 복제하여 관리하는 Object
            * **Service** : **네트워크와 관련**. Pod를 외부 네트워크와 연결해주고 여러 개의 Pod를 바라보는 내부 로드밸런서를 생성할 때 사용
            * **Volume** : 저장소와 관련. 호스트 디렉토리를 그대로 이용하거나 클라우드 스토리지를 동적으로 생성하여 사용할 수 있음
        * Controller : 클러스터의 **실제 상태와 원하는 상태를 관찰하는 무한 루프**
### 클러스터와 마스터 노드
* 쿠버네티스에서는 전체 물리 리소스를 클러스터 단위로 추상화하여 관리함
	* 사용자는 이러한 클러스터 단위로 쿠버네티스를 사용하여, 물리적으로는 여러 대의 서버가 분리되어 있어도 사용자의 입장에서는 하나의 서버를 사용하는 것처럼 사용할 수 있게 됨
    * 쿠버네티스 클러스터는 컨테이너화된 애플리케이션을 실행하는 **노드(워커)들의 집합**
    * 모든 클러스터는 최소 한 개의 워커 노드를 가짐
* 주로 `kubectl` 이라는 CLI 도구를 사용함
* 클러스터 내부에는 클러스터의 구성요소들에 대해 제어 권한을 가진 컨트롤 플레인 (Control Plane) 역할의 마스터 노드를 두게 되며, 관리자는 마스터 노드를 이용하여 클러스터 전체를 제어함
	* 모든 명령은 마스터 노드의 API 서버를 호출하고, 노드는 마스터와 통신하면서 필요한 작업을 수행함
    * 마스터 노드에는 엄격한 보안 설정이 필요하며, 고가용성을 위해 여러 대를 구성하기도 함
* **컨트롤 플레인 (Control Plane)** 의 구성
	* **API** : kubectl 요청 뿐 아니라 내부 노드까지의 모든 요청을 처리하는 모듈
      * 실제로는 선언된 상태를 key-value 저장소에 저장하고, 저장된 상태를 조회하는 작업 수행
      * 권한을 체크하여 요청을 거부할 수도 있음
      * 디버거 역할 수행
    * **etcd** : RAFT 알고리즘을 이용한 key-value 저장소
	  * 쿠버네티스 클러스터 데이터(pod 수, 상태, 네임 스페이스 등), API 객체 및 서비스 검색 세부정보 저장에 사용되는 분산 키 값 저장소 
      * 여러 개로 분산하여 복제함으로써 안정성을 높였으며, 속도 또한 빠름
      * 클러스터의 모든 설정, 상태 데이터가 저장됨
        * 따라서 etcd만 잘 백업하면 언제든 다시 클러스터를 복구할 수 있음
      * etcd는 오직 API 서버와 통신함
    * **Scheduler** : 할당되지 않은 Pod를 여러 가지 조건(자원, 라벨)에 따라 적절한 노드 서버에 할당해주는 모듈
    * **CM (Controller Manager)** : 현재 상태를 선언된 상태로 유지하기 위해 쿠버네티스에 있는 거의 모든 **오브젝트 상태**를 관리, CM은 내부에 다양한 컨트롤러들을 포함하고 관리하는 데몬이며 이들 컨트롤러들은 오브젝트별로 철처히 분업화되어 있음
    * **CCM (Cloud Controller Manager)** : 클라우드(AWS, Azure, GCP) 에 특화된 모듈로써, 클라우드별 제어 로직을 포함하고 있고 각 클라우드 업체에서 자체 모듈을 만들어서 제공하고 있음
* **노드**의 구성
	* **kubelet** : Control Plane의 API 서버가 전달해 준 명령을 받고 본인 노드의 현재 상태를 다시 API 서버에 전달하는 역할
      * 노드에 할당된 Pod의 생명주기 관리 (컨테이너 생성 등)
    * **kube-proxy** : kubelet이 Pod를 관리하면, proxy는 Pod로 연결되는 네트워크를 관리함
      * 여러 개의 Pod를 라운드 로빈 (RR; Round Robin) 형태로 묶어 서비스를 제공할 수 있음
### Pod 생성 과정
1. 사용자의 요청 (`create Pod`)이 API 서버로 옴
2. API 서버는 요청을 etcd에 기록함
3. API 서버를 통해 이를 지켜보고 있던 Scheduler는 해당 Pod를 배치할 노드를 선택함
4. 해당 정보를 다시 API 서버를 통해 etcd에 기록함
5. kubelet은 API 서버를 통해 etcd에 새로운 이벤트가 있다는 것을 감지하고 이에 맞게 컨테이너를 구동함
6. 마지막 API 서버를 통해 구동된 컨테이너 정보를 다시 etcd에 기록함
### ReplicaSet 생성 과정
(3개의 Pod가 운용중이라는 가정 하)  
1. 쿠버네티스 클라이언트는 API 서버로 `replicaset.yaml` 파일에 정의된 ReplicaSet 생성을 요청
2. 해당하는 컨트롤러 (ReplicaSet Controller) 는 관련 정보를 모니터링하다 새로운 ReplicaSet 객체가 있음을 감지
3. 파일의 replica 복제본 값에 따라 컨트롤러는 Pod를 구성된 값의 개수로 정의함
4. API 서버를 통해 이를 지켜보고 있던 Scheduler는 할당하지 않은 Pod가 있음을 감지
5. Scheduler는 Pod를 할당할 노드를 결정하고, 해당 정보를 API 서버에 전달
6. 이를 감시하더 kubelet은 API 서버를 통해 새롭게 할당된 Pod를 감지
7. kubelet은 Docker에 해당하는 컨테이너 생성을 요청
8. kubelet은 API 서버에 업데이트된 Pod 상태를 보냄

