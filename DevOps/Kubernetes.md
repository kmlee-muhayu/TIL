# 쿠버네티스 (Kubernetes)
### 전통적인 배포 시대
* 전통적인 배포 때에는 물리 서버에 애플리케이션을 실행했다.
* 한 물리 서버에서 여러 애플리케이션의 한계를 정의할 방법이 없기 때문에, 리소스 할당 문제 발생
	* 물리 서버 하나에서 무거운 인스턴스를 돌릴 경우 다른 인스턴스에 대한 성능이 저하됨
* 당시 서로 다른 **여러 물리 서버**에서 각 애플리케이션을 실행하여 이러한 문제를 해결하려 함
	* 이는 많은 물리 서버를 유지해야 하기 때문에 많은 비용을 요구하였으며 안정적이지만 비효율적인 구조였음
### 가상화된 배포 시대
* 가상화된 배포 시대에는 단일 물리 서버의 CPU에서 여러 가상 시스템 (Virtual Machine) 을 실행할 수 있게 함
* **하나의 Host OS 위에 여러 개의 OS를 실행한다는 점**에서 가상 시스템은 리소스를 많이 잡아먹어 무겁다는 단점이 있음
### 컨테이너 개발 시대
* **컨테이너** : VM과 유사하지만 가상화를 좀 더 경량화된 프로세스의 개념으로 만든 기술을 의미
	* Host OS 위에 컨테이너 엔진을 설치하고, 애플리케이션 작동에 필요한 바이너리, 라이브러리 등을 하나로 모아 각자가 별도의 서버인 것처럼 사용하는 환경
* 컨테이너는 **이전보다 빠르고 가볍게 가상화를 구현할 수 있게** 해주었으며, **유연하고 자유로운 마이크로서비스**를 관리하기 용이하게 해주었음
### 쿠버네티스란?
* **탄력적인 컨테이너 운용**을 위한 솔루션
* 만약 컨테이너가 다운되면 **시스템이 복제해두었던 다른 컨테이너를 다시 실행하는 방식**으로 문제를 해결한다면 어떨까?
	* 위와 같은 생각에서 컨테이너 오케스트레이션 도구가 등장함
      * **컨테이너 오케스트레이션** : 컨테이너화된 애플리케이션에 대한 자동화된 설정, 관리 및 제어 체계
      * 쿠버네티스는 컨테이너 오케스트레이션 도구 중 가장 널리 사용되는 오픈소스 툴
### 관련 용어
|용어|의미|
|---|---|
|컨테이너|애플리케이션이 구동되는 환경까지 감싸서 실행할 수 있도록 하는 격리 기술|
|컨테이너 런타임|컨테이너를 다루는 도구|
|도커|컨테이너를 다루는 도구 중 가장 많이 사용되는 도구|
|쿠버네티스|컨테이너 런타임을 통해 컨테이너를 오케스트레이션하는 도구|
|오케스트레이션|여러 서버에 걸친 컨테이너 및 사용하는 환경 설정을 관리하는 행위|
### 쿠버네티스 특징
1. 모든 리소스는 **오브젝트 형태**로 관리
	* 쿠버네티스에서는 **컨테이너의 집합**(Pods), 컨테이너의 집합을 관리하는 **컨트롤러**(ReplicaSet), 사용자(Service Account), 노드(Node)까지 하나의 오브젝트로 사용할 수 있다.
    * `kubectl api-resource`
      * 쿠버네티스에서 사용할 수 있는 오브젝트 종류 출력 명령어
    * `kubectl explain pod[오브젝트]`
      * 특정 오브젝트의 간략한 설명 출력
2. 명령어를 사용할 수 있지만 기본적으로 **YAML 파일**을 더 많이 사용
	* 쿠버네티스의 대부분의 작업은 `kubectl` 이라는 명령어로 실행할 수 있다.
    * YAML 파일로 컨테이너 뿐 아니라 거의 모든 오브젝트들에 사용될 수 있다.
      * 컨테이너 자체, 컨테이너 설정값(ConfigMap), 비밀값(Secrets) 등도 모두 YAML 파일로 정의해 사용 가능
    * 실제 서비스를 배포시킬 때도 여러 개의 YAML 파일을 정의해 쿠버네티스에 적용시키는 방식으로 동작한다.
### 쿠버네티스의 기능
* **서비스 디스커버리와 로드밸런싱**
	* 쿠버네티스는 별도의 DNK 구성 없이 DNS 이름을 사용하거나 IP 주소를 사용하여 컨테이너를 노출할 수 있다.
    * 트래픽이 많아지면 쿠버네티스는 자동으로 네트워크 트래픽을 로드밸런싱하여, 배포가 안정적으로 이루어질 수 있도록 한다.
* **스토리지 오케스트레이션**
	* 로컬 저장소, 공용 클라우드 등과 같이 원하는 저장소 시스템을 자동으로 탑재할 수 있다.
* **자동화된 롤아웃과 롤백**
	* 배포된 컨테이너의 원하는 상태를 서술할 수 있으며, 원하는 상태로 설정한 속도에 따라 변경할 수 있다.
    * 장애 시 애플리케이션 롤백 또한 지원
* **자동화된 빈 패킹 (bin packing)**
	* 각 컨테이너에 필요한 CPU 및 메모리의 양을 지정할 수 있다.
      * 컨테이너화된 작업을 실행하는 데 사용할 수 있는 쿠버네티스 클러스터 노드를 제공하여, 쿠버네티스는 컨테이너를 노드에 맞추어 리소스를 가장 잘 사용할 수 있도록 해줌
* **시크릿과 구성 (config) 관리**
	* 암호, OAuth 토큰 및 SSH 키와 같은 중요한 정보를 저장하고 관리할 수 있다.
    * 컨테이너 이미지를 재구성하지 않고 스택 구성에 시크릿을 저장하지 않고도 시크릿 및 애플리케이션 구성을 배포 및 업데이트할 수 있다.
* **자동화된 복구**
	* 쿠버네티스는 패한 컨테이너를 다시 시작하고, 컨테이너를 교체하며, 사용자 정의 상태 검사에 응답하지 않는 컨테이너를 죽이고, 서비스 준비가 끝날 때까지 이러한 과정을 클라이언트에게 보여주지 않는다.
* **배치 실행**
	* 배치 (실시간으로 처리하는 것이 아닌 일괄적으로 모아 한 번에 처리하는 것) 단위 작업을 실행할 수 있도록 하며, 주기적인 배치 작업도 실행할 수 있다.
* **오토 스케일링**
	* 자동으로 애플리케이션의 스케일을 넓히거나 줄일 수 있다. (Horizontal Scaling)
### 쿠버네티스 아키텍처
* 쿠버네티스는 **클러스터 구조**로써, 클러스터 전체를 관리하는 컨트롤러인 **마스터 노드**와 컨테이너가 배포되는 **워커 노드**로 구성되어 있다.
#### Master Node
* 클러스터 전반의 모든 파드(Pod)에 대한 제어 권한을 가지며 워커 노드에서 실행하는 애플리케이션의 스케줄링, 배포, 확장, 업데이트, 롤백 등을 담당
* 보안상의 이유로 일반적으로 외부에서 직접 접근하지 않고, API 서버를 통해 통신
1. **Kube-api-server** (API 서버)
   * 쿠버네티스의 모든 명령과 통신을 수행하는 api의 중심 
2. **etcd**
   * 클러스터 상태 및 설정값 등 구성 정보를 저장하는 분산형 Key-Value 데이터베이스 역할
3. **kube-scheduler** (스케줄러)
   * 새로운 파드를 생성할 떄 어떤 워커 노드에 할당할지 결정
4. **kube-controller-manager**
   * 컨트롤러를 생성하고 각 노드에 배포하여 이를 관리하는 역할
5. **cloud-controller-manager**
   * 쿠버네티스의 컨트롤러들을 클라우드 서비스와 연결해 관리하는 컴포넌트
#### Worker Node
* 마스터에 의해 명령을 받고 실제 워크로드를 생성하여 서비스하는 컴포넌트
1. **kubelet**
	* 파드 컨테이너의 실행을 직접 관리하고 해당 컨테이너가 정상적으로 실행되는지 헬스 체크를 진행한다.
    * 마스터의 API 서버와 통신을 하면서 마스터에 노드의 상태를 전달하거나, 노드가 수행해야 할 명령을 받아서 수행한다.
2. **kube-proxy**
	* 쿠버네티스는 클러스터 안에서 별도의 가상 네트워크를 생성하고 관리한다.
    * 노드로 들어오려는 네트워크 트래픽을 적절한 컨테이너로 라우팅하고, 로드밸런싱을 통해 노드로 들어오고 나가는 네트워크 트래픽을 프록시하며, 노드와 마스터 간 네트워크 통신을 관리한다.
3. **container runtime**
	* 파드를 통해 배포된 컨테이너를 실행하는 컴포넌트
    * 가장 많이 사용되는 런타임으로는 Docker를 사용한다.
### 쿠버네티스 구성요소
* 쿠버네티스를 구성하는 **객체(Object)**와 객체를 관리하는 **컨트롤러(Controller)**가 있다.
#### 객체(Object)
* **파드(Pod)**
  * 쿠버네티스의 가장 기본적인 배포 단위
    * 쿠버네티스는 컨테이너를 직접 관리하는 게 아닌 이러한 파드를 관리하게 된다.
  * 파드에는 컨테이너 이미지 하나만 올리지 않고, 컨테이너와 네트워크 및 스토리지가 포함된 파드로 배포 가능하다.
  * 
  * 기본적으로 하나의 파드에 1개의 컨테이너를 올리지만 하나 이상의 컨테이너를 배포할 수도 있다.
    * 파드 내부의 컨테이너가 전부 실행되어야 파드의 상태가 Running이 된다.
    * **파드 내의 컨테이너들은 서로 IP와 Port를 공유한다.**
    * **파드 내의 모든 컨테이너가 공유하는 볼륨을 설정할 수 있다.**
  * 예시
```yaml
apiVersion: v1
kind: Pod
metadata:
	name: Test-Pod
spec:
	containers:
	  - name: apache
		image: httpd:latest
  		ports:
		  - containerPort: 80
	containers:
	  - name: mysql
		image: mysql:latest
		ports:
		  - containerPort: 3306
```
* **서비스(Service)**
  * 파드는 삭제되고 재생성되는 작업이 빈번해 IP가 고정적이지 않고 계속해서 변경되는데, 이처럼 **계속 변경되는 IP를 고정적으로 하고 내부, 외부에서 파드로 접근하기 쉽게끔** 하기 위해 사용
  * Label과 Label Selector를 사용하며, 일치하는 Label을 가진 Pod에 접근할 수 있다.
  * 서비스 타입
    * Load Balancer
      * 쿠버네티스 외부에서 접근할 때 부하 분산 기능 제공
    * Cluster IP
      * 서비스의 기본값
      * 클러스터 내부에서 파드끼리 통신하기 위한 기능으로 서비스에 연결된 각 파드들에 접근할 수 있다.
      * 클러스터 내부의 IP이기 때문에 External IP가 존재하지 않아 외부에서는 해당 IP를 통해 접근할 수 없다.
    * Node Port
      * 서비스에 포트를 지정해서 할당하는 방식으로 클러스터 외부, 내부 모두 통신 가능하다.
      * port와 targetPort를 사용해 트래픽을 포트포워딩하게 된다.
      * ```yaml
        port:80
        targetPort:8080
        NodePort:30080
        ```
        * port 80을 통해 파드들의 targetPort 8080으로 접근하는 방식, NodePort를 통해 외부에서 접근 또한 가능
    * External Name
      * 주로 클러스터 내부에서 외부의 특정 주소로 접근할 때 사용한다.
      * ```yaml
        type: ExternalName
        externalName: www.naver.com
        ```
      * 서비스를 www.naver.com 으로 연결해준다.
* **볼륨(Volume)**
  * 컨테이너가 삭제되더라도 데이터가 보존되어야 하는 경우 사용하는 기능
  * 컨테이너가 재시작하더라도 데이터가 사라지지 않고 유지해주는 저장소 역할
  * 볼륨의 종류
    * emptyDir
      * 컨테이너들끼리 데이터를 공유하기 위해 사용
      * 임시 저장소이기 때문에 파드가 삭제될 때 같이 삭제된다.
    * hostPath
      * host의 path를 볼륨으로 사용
      * emptyDir 과는 다르게 path들 각각의 pod들이 마운트해서 공유하기 때문에 파드가 삭제되어도 데이터는 항상 path에 계속 유지
    * PV/PVC
      * Local volume 또는 외부 volume (AWS, Azure, Git, ...)들을 PV(persistent volume)에 정의하고 연결
      * 이러한 PV는 파드에 바로 연결하지 않고 PVC를 통해 연결시킨다.
* **네임스페이스(Namespace)**
  * 쿠버네티스 클러스터 내의 논리적인 분리 단위
  * 네임스페이스를 지정해서 파드, 서비스같이 리소스들을 가상의 그룹으로 만들어 관리할 수 있게 한다.
  * 네임스페이스도 물리적인 분리가 아닌 논리적인 분리, 다른 네임스페이스 간에도 통신 가능하고 서로 영향을 끼칠 수 있다.
#### 컨트롤러(Controller)
* **DemonSet**
* **Deployment**
* **ReplicaSet**
* **StatefulSet**
* **Job**


