# OS 데드락
### 1. Deadlock
* 데드락(Deadlock) : 일련의 프로세스들이 **서로가 가진 자원을 기다리며 block 되어 더 이상 진행될 수 없는** 상태
* 프로세스가 자원을 사용하는 절차
    1. **Request** : 자원을 요청하고, 다른 프로세스가 자원을 사용하고 있어서 받을 수 없다면 대기함
    2. **Allocate** : 자원을 받음
    3. **Use** : 프로세스가 받은 자원을 사용함
    4. **Release** : 프로세스가 자원을 놓아줌
* 데드락은 **모든 프로세스가 Request** 상태되어 있는 상황
### 2. Deadlock Characterization
* 데드락이 발생하기 위해선 아래 4가지 조건을 만족해야 함
1. **Mutual exclusion (상호 배제)**
    * 매 순간 하나의 프로세스만이 자원을 사용할 수 있음
2. **Hold and wait (보유 대기)**
    * 자원을 가진 프로세스가 다른 자원을 기다릴 때, 보유하고 있는 자원을 놓지 않고 계속 가지고 있음
3. **No preemption (비선점)**
    * 프로세스는 OS에 의해 강제로 자원을 빼앗기지 않음
4. **Circular wait (순환 대기)**
    * 자원을 기다리는 프로세스 간에 사이클이 형성되어야 함
    * ex) 프로세스 p0, p1, ... , pn이 있을 때 p0은 p1을 기다리고, p1은 p2를 기다리고, ..., pn은 p0를 기다린다.
    * 만약 자원 할당 그래프 (Resource-Allocation Graph)에 사이클이 없다면 데드락이 아니다.
    * 사이클이 존재한다면 데드락이 발생할 '수' 있다.
* 데드락 문제를 해결하기 위한 방법 중 대표적 방법 
  1. 미리 예방하는 방법(Prevention) 
  2. 데드락이 발생하지 않도록 피하는 방법(Avoidance) 
  3. 발생했을 때 처리하는 방법(Detection and Recovery) 
  4. 무시하는 방법(Ignorance)
### 3. Deadlock Prevention
* 미리 예방하는 방식
* 자원을 할당할 때 **Deadlock의 4가지 필요조건 중 어느 하나가 만족하지 않도록** 하는 방식
    1. **Mutual Exclusion**
        * Critical Section Problem을 해결하기 위해서는 이 조건은 반드시 만족해야 하므로 공유자원이 존재한다면 이 조건은 만족시킬 수밖에 없다. 
    2. **Hold and Wait**
        * 프로세스가 자원을 요청할 때 다른 어떤 자원도 가지고 있지 않도록 해야 함
        * 따라서, 프로세스를 시작할 때 모든 필요한 자원을 할당받게 하거나 자원이 필요한 경우 보유하고 있던 자원을 모두 반납하고 다시 요청하는 방법을 이용할 수 있다.
    3. **No preemption**
        * 프로세스가 어떤 자원을 기다려야 하는 경우 보유하고 있던 자원이 선점된다.
        * 모든 필요한 자원을 얻을 수 있을 때 그 프로세스는 다시 시작된다.
    4. **Circular wait**
        * 자원의 타입에 따라 프로세스마다 할당 순서를 정해진 순서대로만 자원을 할당한다.
### 4. Deadlock Avoidance
* **Deadlock이 발생할 가능성이 있는 경우엔 아예 자원을 할당하지 않는** 방식
* **Safe Sequence** : 프로세스의 sequence <P1, P2, ..., Pn>이 있을 때 Pi의 자원 요청이 `가용 자원 + 모든 Pj (j < i)의 보유 자원`에 의해 충족되는 경우 sequence를 safe 하다고 함
* **Safe state** : 시스템 내의 프로세스들에 대한 Safe Sequence가 존재하는 상태
* 만약 시스템이 **Safe state에 있으면 Deadlock이 발생하지 않는다**.
  * 따라서 Deadlock Avoidance는 **시스템이 Unsafe state에 들어가지 않는 것을 보장하는 것**이다.
### 5. Deadlock Detection and Recovery
* Deadlock을 해결해기 위해 종료시켜야 할 프로세스를 판단할 기준
    1. 프로세스의 중요도
    2. 프로세스가 얼마나 오래 실행되었는가
    3. 프로세스가 얼마나 많은 자원을 사용했는가
    4. 프로세스가 작업을 마치기 위해 얼마나 많은 자원이 필요한가
    5. 프로세스가 종료되기 위해 얼마나 많은 자원이 필요한가
    6. 프로세스가 batch인가 interactive인가
* 해결하는 방법으로는 프로세스를 종료시키거나 자원을 선점하는 방식이 있음
  * 프로세스 종료 : Deadlock에 빠진 모든 프로세스를 종료시키거나, Deadlock이 해결될 때까지 한 번에 한 프로세스씩 종료시킬 수 있다.
  * 자원 선점 : 어떤 프로세스를 종료시킬지 결정(Selecting a victim)하고, Deadlock이 발생하기 전 상태로 돌아가 프로세스를 재시작한다.
    * 동일한 프로세스가 계속해서 victim 으로 선정되는 경우 Starvation이 발생할 수 있다. 이는 Rollback 된 횟수를 저장함으로써 해결할 수 있다.
### 6. Deadlock Ignorance
* **Deadlock이 일어나지 않는다고 생각하고 아무런 조치도 취하지 않는** 방식이다.
* Deadlock이 매우 드물게 발생하기 때문에 Deadlock에 대한 조치 자체가 더 큰 오버헤드일 수 있기 때문
* 만약 시스템에 Deadlock이 발생한 경우, 시스템이 비정상적으로 작동하는 것을 사람이 느낀 후 직접 프로세스를 죽이는 등의 방식으로 대처
* 해당 방식은 **UNIX, Windows 등 대부분의 범용 운영체제**에서 채택하는 방식
